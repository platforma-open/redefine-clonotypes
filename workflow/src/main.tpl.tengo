// "Redefine clonotypes workflow"
wf := import("@platforma-sdk/workflow-tengo:workflow")
ll := import("@platforma-sdk/workflow-tengo:ll")
pt := import("@platforma-sdk/workflow-tengo:pt")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
text := import("text")
slices := import("@platforma-sdk/workflow-tengo:slices")
maps := import("@platforma-sdk/workflow-tengo:maps")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
canonical := import("@platforma-sdk/workflow-tengo:canonical")
json := import("json")
assets := import("@platforma-sdk/workflow-tengo:assets")
render := import("@platforma-sdk/workflow-tengo:render")

anonymizationTpl := assets.importTemplate(":anonymization")
deanonimizationTpl := assets.importTemplate(":deanonimization")
numberingTpl := assets.importTemplate(":anarci-numbering")

// --- Clonotype Label Generation (copied from MiXCR Clonotyping) ---
addClonotypeLabelColumnsPt := func(df, clonotypeKeyCol, clonotypeLabelCol) {
    prefixTempCol := clonotypeLabelCol + "_prefix_temp"
    rankTempCol := clonotypeLabelCol + "_rank_temp"

    df = df.withColumns(
        pt.col(clonotypeKeyCol).
            strReplace("\\d", "", { replaceAll: true }).
            strSlice(0, 5).
            strToUpper().
            alias(prefixTempCol)
    )

    df = df.withColumns(
        pt.rank(pt.col(clonotypeKeyCol)).
            over(pt.col(prefixTempCol)).
            alias(rankTempCol)
    )

    df = df.withColumns(
        pt.when(pt.col(rankTempCol).gt(pt.lit(1))).
            then(pt.concatStr([pt.lit("C"), pt.col(prefixTempCol), pt.col(rankTempCol).cast("String")], { delimiter: "-" })).
            otherwise(pt.concatStr([pt.lit("C"), pt.col(prefixTempCol)], { delimiter: "-" })).
            alias(clonotypeLabelCol)
    )

    return df.withoutColumns(prefixTempCol, rankTempCol)
}


wf.prepare(func(args) {
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.addAnchor("main", args.anchorRef)

	// Clonotype definition columns
	for i, colId in args.clonotypeDefinition {
		bundleBuilder.addSingle(colId, "clonotypeDefinition_" + i)
	}

	// All non-normalized abundance columns
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 0 }, { anchor: "main", idx: 1 }],
		annotations: {
			"pl7.app/isAbundance": "true",
			"pl7.app/abundance/normalized": "false"
		}
	}, "abundances")

	// All clonotype property columns
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }]
	}, "properties")

	// VDJRegion assembling feature sequences (AA/NT)
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }],
		name: "pl7.app/vdj/sequence",
		annotations: { "pl7.app/vdj/isAssemblingFeature": "true" }
	}, "vdjRegionSeqs")

	// CDR3 main sequences (AA/NT)
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }],
		name: "pl7.app/vdj/sequence",
		annotations: { "pl7.app/vdj/isMainSequence": "true" },
		domain: { "pl7.app/vdj/feature": "CDR3" }
	}, "cdr3MainSeqs")

	return {
		columns: bundleBuilder.build()
	}
})

wf.body(func(args) {
	columns := args.columns
	blockId := wf.blockId().getDataAsJson()

	abundanceCols := columns.getColumns("abundances")
	propertyCols := columns.getColumns("properties")
	
	clonotypeDefinitionCols := []
	for i, _ in args.clonotypeDefinition {
		clonotypeDefinitionCols = append(clonotypeDefinitionCols, columns.getColumn("clonotypeDefinition_" + i))
	}

	ll.assert(len(abundanceCols) > 0, "No abundance columns found in the dataset")

	mainAbundanceColIndex := -1
	for i, c in abundanceCols {
		if c.spec.annotations["pl7.app/abundance/isPrimary"] == "true" {
			mainAbundanceColIndex = i
			break
		}
	}
	ll.assert(mainAbundanceColIndex != -1, "No primary abundance column found")
	mainAbundanceCol := abundanceCols[mainAbundanceColIndex]

	sampleIdAxisSpec := mainAbundanceCol.spec.axesSpec[0]
	clonotypeKeyAxisSpec := mainAbundanceCol.spec.axesSpec[1]
	isSingleCell := clonotypeKeyAxisSpec.name == "pl7.app/vdj/scClonotypeKey"

	numberingRegions := ["FR1", "CDR1", "FR2", "CDR2", "FR3", "CDR3", "FR4"]
	numberingScheme := args.numberingScheme
	numberingEnabled := numberingScheme != undefined
	numberingHeaders := []
	numberingSpecs := {}
	numberingLabels := {}
	numberingTsv := undefined
	numberingChains := []
	numberingChainSet := {}
	cdr3Tsv := undefined
	cdr3Chains := []
	cdr3ChainSet := {}
	cdr3HasAa := {}
	cdr3HasNt := {}
	useCdr3Numbering := false
	existingSeqKeys := {}
	cdrAnnotationHeaderChain := {}
	cdrAnnotationMappingByChain := {}
	cdrAnnotationMappingDefault := undefined
	cdrAnnotationAvailableByChain := {}
	hasCdrAnnotationColumns := false
	bulkNumberingChain := undefined

	for i, col in propertyCols {
		if col.spec.name != "pl7.app/vdj/sequence/annotation" { continue }
		if col.spec.domain["pl7.app/sequence/annotation/type"] != "CDRs" { continue }
		hasCdrAnnotationColumns = true
		header := "property_" + i
		chainKey := undefined
		if isSingleCell {
			scChain := col.spec.domain["pl7.app/vdj/scClonotypeChain"]
			chainKey = scChain == "A" ? "H" : scChain == "B" ? "KL" : undefined
		} else {
			chainDomain := col.spec.domain["pl7.app/vdj/chain"]
			if chainDomain == undefined {
				chainDomain = col.spec.axesSpec[0].domain["pl7.app/vdj/chain"]
			}
			chainKey = chainDomain == "IGHeavy" ? "H" : chainDomain == "IGLight" ? "KL" : undefined
		}
		if chainKey != undefined {
			cdrAnnotationHeaderChain[header] = chainKey
		}
		mapping := col.spec.annotations["pl7.app/sequence/annotation/mapping"]
		if mapping != undefined && mapping != "" {
			if chainKey != undefined {
				if is_undefined(cdrAnnotationMappingByChain[chainKey]) {
					cdrAnnotationMappingByChain[chainKey] = mapping
				}
			} else if cdrAnnotationMappingDefault == undefined {
				cdrAnnotationMappingDefault = mapping
			}
		}
	}

	// Anonymize sampleId axis (index 0)
	dataToAnonymize := {}
	for i, col in abundanceCols {
		dataToAnonymize["abundance_" + i] = col.data
	}

	anonymizationResult := render.create(anonymizationTpl, {
		data: dataToAnonymize,
		pKeyIndices: [0]
	})
	mappingRef := anonymizationResult.output("mapping")

	// --- Build the initial TSV for the pt workflow ---
	abundanceTsvBuilder := pframes.tsvFileBuilder()
	abundanceTsvBuilder.setAxisHeader(sampleIdAxisSpec, "sampleId")
	abundanceTsvBuilder.setAxisHeader(clonotypeKeyAxisSpec, "clonotypeKey")

	if numberingEnabled {
		vdjRegionCols := columns.getColumns("vdjRegionSeqs")
		allowedFeatures := { "VDJRegion": true, "VDJRegionInFrame": true }
		aaByChain := {}
		ntByChain := {}
		for _, col in vdjRegionCols {
			feature := col.spec.domain["pl7.app/vdj/feature"]
			if is_undefined(allowedFeatures[feature]) { continue }
			chain := undefined
			if isSingleCell {
				receptor := col.spec.axesSpec[0].domain["pl7.app/vdj/receptor"]
				if receptor != "IG" { continue }
				index := col.spec.domain["pl7.app/vdj/scClonotypeChain/index"]
				if index != "primary" { continue }
				scChain := col.spec.domain["pl7.app/vdj/scClonotypeChain"]
				chain = scChain == "A" ? "IGHeavy" : scChain == "B" ? "IGLight" : undefined
			} else {
				chain = col.spec.axesSpec[0].domain["pl7.app/vdj/chain"]
				if chain == undefined { chain = col.spec.domain["pl7.app/vdj/chain"] }
			}
			alphabet := col.spec.domain["pl7.app/alphabet"]
			chainKey := chain == "IGHeavy" ? "H" : chain == "IGLight" ? "KL" : undefined
			if chainKey == undefined { continue }
			if alphabet == "aminoacid" && is_undefined(aaByChain[chainKey]) {
				aaByChain[chainKey] = col
			} else if alphabet == "nucleotide" && is_undefined(ntByChain[chainKey]) {
				ntByChain[chainKey] = col
			}
		}

		hasH := !is_undefined(aaByChain["H"])
		hasKL := !is_undefined(aaByChain["KL"])

		// CDR3-only fallback (main sequence)
		cdr3Cols := columns.getColumns("cdr3MainSeqs")
		cdr3AaByChain := {}
		cdr3NtByChain := {}
		for _, col in cdr3Cols {
			if col.spec.domain["pl7.app/vdj/feature"] != "CDR3" { continue }
			chain := undefined
			if isSingleCell {
				receptor := col.spec.axesSpec[0].domain["pl7.app/vdj/receptor"]
				if receptor != "IG" { continue }
				index := col.spec.domain["pl7.app/vdj/scClonotypeChain/index"]
				if index != "primary" { continue }
				scChain := col.spec.domain["pl7.app/vdj/scClonotypeChain"]
				chain = scChain == "A" ? "IGHeavy" : scChain == "B" ? "IGLight" : undefined
			} else {
				chain = col.spec.axesSpec[0].domain["pl7.app/vdj/chain"]
				if chain == undefined { chain = col.spec.domain["pl7.app/vdj/chain"] }
			}
			alphabet := col.spec.domain["pl7.app/alphabet"]
			chainKey := chain == "IGHeavy" ? "H" : chain == "IGLight" ? "KL" : undefined
			if chainKey == undefined { continue }
			if alphabet == "aminoacid" && is_undefined(cdr3AaByChain[chainKey]) {
				cdr3AaByChain[chainKey] = col
			} else if alphabet == "nucleotide" && is_undefined(cdr3NtByChain[chainKey]) {
				cdr3NtByChain[chainKey] = col
			}
		}

		hasCdr3H := !is_undefined(cdr3AaByChain["H"])
		hasCdr3KL := !is_undefined(cdr3AaByChain["KL"])
		useVdjRegionNumbering := hasH || hasKL
		useCdr3Numbering = !useVdjRegionNumbering && (hasCdr3H || hasCdr3KL)

		if isSingleCell {
			ll.assert(useVdjRegionNumbering ? (hasH && hasKL) : (hasCdr3H && hasCdr3KL), "Sequences for both chains are required for numbering")
		} else {
			ll.assert(useVdjRegionNumbering || useCdr3Numbering, "VDJRegion or CDR3 amino acid sequence is required for numbering")
		}

		if useVdjRegionNumbering {
			numberingAaTsvBuilder := pframes.tsvFileBuilder()
			numberingAaTsvBuilder.setAxisHeader(clonotypeKeyAxisSpec, "clonotypeKey")
			numberingInputTsvBuilder := pframes.tsvFileBuilder()
			numberingInputTsvBuilder.setAxisHeader(clonotypeKeyAxisSpec, "clonotypeKey")

			for _, chainKey in ["H", "KL"] {
				col := aaByChain[chainKey]
				if col != undefined {
					headerAa := "vdjRegion_aa_" + chainKey
					numberingAaTsvBuilder.add(col, { header: headerAa })
					numberingInputTsvBuilder.add(col, { header: headerAa })
				}
			}
			for _, chainKey in ["H", "KL"] {
				col := ntByChain[chainKey]
				if col != undefined {
					headerNt := "vdjRegion_nt_" + chainKey
					numberingInputTsvBuilder.add(col, { header: headerNt })
				}
			}

			numberingAaTsvBuilder.mem("16GiB")
			numberingAaTsvBuilder.cpu(1)
			numberingInputTsvBuilder.mem("16GiB")
			numberingInputTsvBuilder.cpu(1)

			numberingAaTsv := numberingAaTsvBuilder.build()
			numberingInputTsv := numberingInputTsvBuilder.build()

			bulkChain := undefined
			if !isSingleCell {
				bulkChain = hasH ? "H" : "KL"
			}
			bulkNumberingChain = bulkChain

			cdrMappingH := cdrAnnotationMappingByChain["H"]
			cdrMappingKL := cdrAnnotationMappingByChain["KL"]
			if cdrMappingH == undefined { cdrMappingH = cdrAnnotationMappingDefault }
			if cdrMappingKL == undefined { cdrMappingKL = cdrAnnotationMappingDefault }
			if cdrMappingH != undefined { cdrAnnotationAvailableByChain["H"] = true }
			if cdrMappingKL != undefined { cdrAnnotationAvailableByChain["KL"] = true }

			numbering := render.create(numberingTpl, {
				inputAaTsv: numberingAaTsv,
				inputTsv: numberingInputTsv,
				scheme: numberingScheme,
				isSingleCell: isSingleCell,
				bulkChain: bulkChain,
				cdrMappingH: cdrMappingH,
				cdrMappingKL: cdrMappingKL
			})
			numberingTsv = numbering.output("numbered", 24 * 60 * 60 * 1000)
		}

		if useCdr3Numbering {
			cdr3TsvBuilder := pframes.tsvFileBuilder()
			cdr3TsvBuilder.setAxisHeader(clonotypeKeyAxisSpec, "clonotypeKey")
			for _, chainKey in ["H", "KL"] {
				col := cdr3AaByChain[chainKey]
				if col != undefined {
					headerAa := "cdr3_aa_" + chainKey
					cdr3TsvBuilder.add(col, { header: headerAa })
					cdr3HasAa[chainKey] = true
					if is_undefined(cdr3ChainSet[chainKey]) {
						cdr3ChainSet[chainKey] = true
						cdr3Chains = append(cdr3Chains, chainKey)
					}
				}
			}
			for _, chainKey in ["H", "KL"] {
				col := cdr3NtByChain[chainKey]
				if col != undefined {
					headerNt := "cdr3_nt_" + chainKey
					cdr3TsvBuilder.add(col, { header: headerNt })
					cdr3HasNt[chainKey] = true
					if is_undefined(cdr3ChainSet[chainKey]) {
						cdr3ChainSet[chainKey] = true
						cdr3Chains = append(cdr3Chains, chainKey)
					}
				}
			}
			cdr3TsvBuilder.mem("16GiB")
			cdr3TsvBuilder.cpu(1)
			cdr3Tsv = cdr3TsvBuilder.build()
		}

		schemeLabel := numberingScheme == "imgt" ? "IMGT" : numberingScheme == "kabat" ? "Kabat" : "Chothia"
		for _, chainKey in ["H", "KL"] {
			if is_undefined(aaByChain[chainKey]) { continue }
			if is_undefined(numberingChainSet[chainKey]) {
				numberingChainSet[chainKey] = true
				numberingChains = append(numberingChains, chainKey)
			}
			chainDomain := chainKey == "H" ? "IGHeavy" : "IGLight"
			chainLabel := chainKey == "H" ? "Heavy" : "Light"
			for _, region in numberingRegions {
				for _, alphabet in ["aminoacid", "nucleotide"] {
					header := numberingScheme + "_" + region + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
					numberingHeaders = append(numberingHeaders, header)
					numberingLabels[header] = schemeLabel + " " + region + " " + (alphabet == "aminoacid" ? "aa" : "nt") + " " + chainLabel
					numberingSpecs[header] = {
						name: "pl7.app/vdj/sequence",
						valueType: "String",
						domain: {
							"pl7.app/vdj/feature": region,
							"pl7.app/vdj/chain": chainDomain,
							"pl7.app/alphabet": alphabet
						},
						annotations: {
							"pl7.app/label": numberingLabels[header],
							"pl7.app/table/visibility": "optional",
							"pl7.app/vdj/numberingSchema": numberingScheme
						}
					}
				}
			}
			for _, feature in ["VDJRegion", "VDJRegionInFrame"] {
				for _, alphabet in ["aminoacid", "nucleotide"] {
					header := numberingScheme + "_" + feature + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
					numberingHeaders = append(numberingHeaders, header)
					numberingLabels[header] = schemeLabel + " " + feature + " " + (alphabet == "aminoacid" ? "aa" : "nt") + " " + chainLabel
					numberingSpecs[header] = {
						name: "pl7.app/vdj/sequence",
						valueType: "String",
						domain: {
							"pl7.app/vdj/feature": feature,
							"pl7.app/vdj/chain": chainDomain,
							"pl7.app/alphabet": alphabet
						},
						annotations: {
							"pl7.app/label": numberingLabels[header],
							"pl7.app/table/visibility": "optional",
							"pl7.app/vdj/numberingSchema": numberingScheme
						}
					}
				}
			}
		}
	}

	mainAbundanceHeader := "abundance_" + mainAbundanceColIndex
	
	abundanceHeaders := {}
	for i, col in abundanceCols {
		header := "abundance_" + i
		anonymizedData := anonymizationResult.resolveOutput(["anonymizedData", "abundance_" + i])
		anonymizedCol := { spec: col.spec, data: anonymizedData }
		abundanceHeaders[header] = anonymizedCol
		abundanceTsvBuilder.add(anonymizedCol, { header: header })
	}
	
	definitionHeaders := []
	definitionLabels := []
	definitionHeaderSet := {}
	appendDefinition := func(header, label) {
		if label == undefined { label = header }
		if is_undefined(definitionHeaderSet[header]) {
			definitionHeaderSet[header] = true
			definitionHeaders = append(definitionHeaders, header)
			definitionLabels = append(definitionLabels, label)
		}
	}
	for i, col in clonotypeDefinitionCols {
		header := "clonotypeDefinition_" + i
		label := col.spec.annotations["pl7.app/label"]
		abundanceTsvBuilder.add(col, { header: header })

		useNumbered := false
		feature := col.spec.domain["pl7.app/vdj/feature"]
		if numberingEnabled && col.spec.name == "pl7.app/vdj/sequence" && col.spec.annotations["pl7.app/vdj/isAssemblingFeature"] == "true" && (feature == "VDJRegion" || feature == "VDJRegionInFrame") {
			chain := undefined
			if isSingleCell {
				receptor := col.spec.axesSpec[0].domain["pl7.app/vdj/receptor"]
				if receptor != "IG" { chain = undefined } else {
					index := col.spec.domain["pl7.app/vdj/scClonotypeChain/index"]
					if index != "primary" { chain = undefined } else {
						scChain := col.spec.domain["pl7.app/vdj/scClonotypeChain"]
						chain = scChain == "A" ? "IGHeavy" : scChain == "B" ? "IGLight" : undefined
					}
				}
			} else {
				chain = col.spec.axesSpec[0].domain["pl7.app/vdj/chain"]
				if chain == undefined { chain = col.spec.domain["pl7.app/vdj/chain"] }
			}
			alphabet := col.spec.domain["pl7.app/alphabet"]
			chainKey := chain == "IGHeavy" ? "H" : chain == "IGLight" ? "KL" : undefined
			if chainKey != undefined && (alphabet == "aminoacid" || alphabet == "nucleotide") {
				headerNum := numberingScheme + "_" + feature + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				appendDefinition(headerNum, numberingLabels[headerNum])
				useNumbered = true
			}
		}
		if !useNumbered {
			appendDefinition(header, label)
		}
	}

	abundancesTsv := abundanceTsvBuilder.build()

	propertyTsvBuilder := pframes.tsvFileBuilder()
	propertyTsvBuilder.setAxisHeader(clonotypeKeyAxisSpec, "clonotypeKey")
	propertyHeaders := {}
	for i, col in propertyCols {
		header := "property_" + i
		propertyHeaders[header] = col
		propertyTsvBuilder.add(col, { header: header })
	}
	propertiesTsv := propertyTsvBuilder.build()

	
	// --- Define the entire data pipeline in a single pt workflow ---
	ptWf := pt.workflow()

	df := ptWf.frame(abundancesTsv, {xsvType: "tsv"})
	numberingDf := undefined
	if numberingTsv != undefined {
		numberingDf = ptWf.frame(numberingTsv, {xsvType: "tsv"})
		df = df.join(numberingDf, {on: "clonotypeKey", how: "left"})
		numberingDerivedExprs := []
		for _, chainKey in numberingChains {
			for _, alphabet in ["aminoacid", "nucleotide"] {
				regionHeaders := []
				for _, region in numberingRegions {
					regionHeaders = append(regionHeaders, numberingScheme + "_" + region + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey)
				}
				vdjHeader := numberingScheme + "_VDJRegion_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				vdjInFrameHeader := numberingScheme + "_VDJRegionInFrame_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				concatExpr := pt.concatStr(slices.map(regionHeaders, func(h) { return pt.col(h) }), {delimiter: ""})
				numberingDerivedExprs = append(numberingDerivedExprs,
					concatExpr.alias(vdjHeader),
					concatExpr.alias(vdjInFrameHeader)
				)
				fr4Header := numberingScheme + "_FR4_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				fr4InFrameHeader := numberingScheme + "_FR4InFrame_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				numberingDerivedExprs = append(numberingDerivedExprs,
					pt.col(fr4Header).alias(fr4InFrameHeader)
				)
			}
		}
		if len(numberingDerivedExprs) > 0 {
			df = df.withColumns(numberingDerivedExprs...)
		}
	}
	cdr3Df := undefined
	if cdr3Tsv != undefined {
		cdr3Df = ptWf.frame(cdr3Tsv, {xsvType: "tsv"})
		df = df.join(cdr3Df, {on: "clonotypeKey", how: "left"})
		cdr3DerivedExprs := []
		for _, chainKey in cdr3Chains {
			aaCol := "cdr3_aa_" + chainKey
			ntCol := "cdr3_nt_" + chainKey
			isImgt := numberingScheme == "imgt"
			if !is_undefined(cdr3HasAa[chainKey]) {
				aaLen := pt.col(aaCol).strLenChars()
				aaFr3Len := isImgt ? 1 : 3
				aaFr4 := pt.col(aaCol).strSlice(aaLen.minus(1), 1)
				aaTrimLen := aaLen.minus(aaFr3Len + 1)
				aaTrim := pt.col(aaCol).strSlice(aaFr3Len, { length: aaTrimLen })
				cdr3DerivedExprs = append(cdr3DerivedExprs,
					aaTrim.alias("cdr3_trim_aa_" + chainKey)
				)
				if !is_undefined(existingSeqKeys["FR4|aminoacid|" + chainKey]) {
					cdr3DerivedExprs = append(cdr3DerivedExprs,
						aaFr4.alias(numberingScheme + "_FR4_aa_" + chainKey)
					)
				}
				if !is_undefined(existingSeqKeys["FR4InFrame|aminoacid|" + chainKey]) {
					cdr3DerivedExprs = append(cdr3DerivedExprs,
						aaFr4.alias(numberingScheme + "_FR4InFrame_aa_" + chainKey)
					)
				}
			}
			if !is_undefined(cdr3HasNt[chainKey]) {
				ntLen := pt.col(ntCol).strLenChars()
				ntFr3Len := isImgt ? 3 : 9
				ntFr4 := pt.col(ntCol).strSlice(ntLen.minus(3), 3)
				ntTrimLen := ntLen.minus(ntFr3Len + 3)
				ntTrim := pt.col(ntCol).strSlice(ntFr3Len, { length: ntTrimLen })
				cdr3DerivedExprs = append(cdr3DerivedExprs,
					ntTrim.alias("cdr3_trim_nt_" + chainKey)
				)
				if !is_undefined(existingSeqKeys["FR4|nucleotide|" + chainKey]) {
					cdr3DerivedExprs = append(cdr3DerivedExprs,
						ntFr4.alias(numberingScheme + "_FR4_nt_" + chainKey)
					)
				}
				if !is_undefined(existingSeqKeys["FR4InFrame|nucleotide|" + chainKey]) {
					cdr3DerivedExprs = append(cdr3DerivedExprs,
						ntFr4.alias(numberingScheme + "_FR4InFrame_nt_" + chainKey)
					)
				}
			}
		}
		if len(cdr3DerivedExprs) > 0 {
			df = df.withColumns(cdr3DerivedExprs...)
		}
	}

	// 1. Calculate per-sample totals for each abundance column for normalization
	sampleTotalAggs := []
	totalColumnHeaders := []
	for header, _ in abundanceHeaders {
		totalHeader := header + "_total"
		sampleTotalAggs = append(sampleTotalAggs, pt.col(header).sum().alias(totalHeader))
		totalColumnHeaders = append(totalColumnHeaders, totalHeader)
	}
	sampleTotalsDf := df.groupBy("sampleId").agg(sampleTotalAggs...)

	// 2. Create the new clonotype definition string
	definitionColExprs := slices.map(definitionHeaders, func(h) { return pt.col(h) })
	dfWithNewKeyStr := df.withColumns(
		pt.
		  concatStr(definitionColExprs, {delimiter: "-"}).
		  hash("sha256", "base64_alphanumeric", 120).
		  alias("newClonotypeKey")
	)
	
	// 3. Calculate stats
	statsDf := dfWithNewKeyStr.select(
		pt.col("clonotypeKey").nUnique().alias("nClonotypesBefore"),
		pt.col("newClonotypeKey").nUnique().alias("nClonotypesAfter")
	)
	statsDf.saveContent("stats.tsv")

	// 4. Aggregate abundances
	abundanceAggs := []
	for h in maps.getKeys(abundanceHeaders) { 
		abundanceAggs = append(abundanceAggs, pt.col(h).sum().alias(h)) 
	}
	abundanceAggs = append(abundanceAggs, pt.col("clonotypeKey").maxBy(pt.col(mainAbundanceHeader)).alias("clonotypeKey"))
	df_abundances := dfWithNewKeyStr.groupBy("sampleId", "newClonotypeKey").agg(abundanceAggs...)

	// 8. Per-sample normalization
	df_abundances = df_abundances.join(sampleTotalsDf, {on: "sampleId", how: "left"})

	normExpressions := []
	for header, _ in abundanceHeaders {
		normExpressions = append(normExpressions, 
			pt.col(header).truediv(pt.col(header + "_total")).alias("normalized_" + header)
		)
	}
	df_abundances = df_abundances.withColumns(normExpressions...)
	df_abundances.save("abundances.tsv")

	// 5. Get representative properties

	existingSeqKeys = {}
	for h, col in propertyHeaders {
		if col.spec.name != "pl7.app/vdj/sequence" { continue }
		feature := col.spec.domain["pl7.app/vdj/feature"]
		chain := undefined
		if isSingleCell {
			receptor := col.spec.axesSpec[0].domain["pl7.app/vdj/receptor"]
			if receptor == "IG" {
				index := col.spec.domain["pl7.app/vdj/scClonotypeChain/index"]
				if index == "primary" {
					scChain := col.spec.domain["pl7.app/vdj/scClonotypeChain"]
					chain = scChain == "A" ? "IGHeavy" : scChain == "B" ? "IGLight" : undefined
				}
			}
		} else {
			chain = col.spec.axesSpec[0].domain["pl7.app/vdj/chain"]
			if chain == undefined { chain = col.spec.domain["pl7.app/vdj/chain"] }
		}
		alphabet := col.spec.domain["pl7.app/alphabet"]
		chainKey := chain == "IGHeavy" ? "H" : chain == "IGLight" ? "KL" : undefined
		if chainKey != undefined && alphabet != undefined && feature != undefined {
			existingSeqKeys[feature + "|" + alphabet + "|" + chainKey] = true
		}
	}
	
	df_properties := df_abundances.join(ptWf.frame(propertiesTsv, {xsvType: "tsv"}), {on: "clonotypeKey", how: "left"})
	if numberingDf != undefined {
		df_properties = df_properties.join(numberingDf, {on: "clonotypeKey", how: "left"})
		numberingDerivedExprsProps := []
		for _, chainKey in numberingChains {
			for _, alphabet in ["aminoacid", "nucleotide"] {
				regionHeaders := []
				for _, region in numberingRegions {
					regionHeaders = append(regionHeaders, numberingScheme + "_" + region + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey)
				}
				vdjHeader := numberingScheme + "_VDJRegion_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				vdjInFrameHeader := numberingScheme + "_VDJRegionInFrame_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				concatExpr := pt.concatStr(slices.map(regionHeaders, func(h) { return pt.col(h) }), {delimiter: ""})
				numberingDerivedExprsProps = append(numberingDerivedExprsProps,
					concatExpr.alias(vdjHeader),
					concatExpr.alias(vdjInFrameHeader)
				)
				fr4Header := numberingScheme + "_FR4_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				fr4InFrameHeader := numberingScheme + "_FR4InFrame_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				numberingDerivedExprsProps = append(numberingDerivedExprsProps,
					pt.col(fr4Header).alias(fr4InFrameHeader)
				)
			}
		}
		if len(numberingDerivedExprsProps) > 0 {
			df_properties = df_properties.withColumns(numberingDerivedExprsProps...)
		}
	}
	if cdr3Df != undefined {
		df_properties = df_properties.join(cdr3Df, {on: "clonotypeKey", how: "left"})
		cdr3DerivedExprsProps := []
		for _, chainKey in cdr3Chains {
			aaCol := "cdr3_aa_" + chainKey
			ntCol := "cdr3_nt_" + chainKey
			isImgt := numberingScheme == "imgt"
			if !is_undefined(cdr3HasAa[chainKey]) {
				aaLen := pt.col(aaCol).strLenChars()
				aaFr3Len := isImgt ? 1 : 3
				aaFr4 := pt.col(aaCol).strSlice(aaLen.minus(1), 1)
				aaTrimLen := aaLen.minus(aaFr3Len + 1)
				aaTrim := pt.col(aaCol).strSlice(aaFr3Len, { length: aaTrimLen })
				cdr3DerivedExprsProps = append(cdr3DerivedExprsProps,
					aaTrim.alias("cdr3_trim_aa_" + chainKey)
				)
				if !is_undefined(existingSeqKeys["FR4|aminoacid|" + chainKey]) {
					cdr3DerivedExprsProps = append(cdr3DerivedExprsProps,
						aaFr4.alias(numberingScheme + "_FR4_aa_" + chainKey)
					)
				}
				if !is_undefined(existingSeqKeys["FR4InFrame|aminoacid|" + chainKey]) {
					cdr3DerivedExprsProps = append(cdr3DerivedExprsProps,
						aaFr4.alias(numberingScheme + "_FR4InFrame_aa_" + chainKey)
					)
				}
			}
			if !is_undefined(cdr3HasNt[chainKey]) {
				ntLen := pt.col(ntCol).strLenChars()
				ntFr3Len := isImgt ? 3 : 9
				ntFr4 := pt.col(ntCol).strSlice(ntLen.minus(3), 3)
				ntTrimLen := ntLen.minus(ntFr3Len + 3)
				ntTrim := pt.col(ntCol).strSlice(ntFr3Len, { length: ntTrimLen })
				cdr3DerivedExprsProps = append(cdr3DerivedExprsProps,
					ntTrim.alias("cdr3_trim_nt_" + chainKey)
				)
				if !is_undefined(existingSeqKeys["FR4|nucleotide|" + chainKey]) {
					cdr3DerivedExprsProps = append(cdr3DerivedExprsProps,
						ntFr4.alias(numberingScheme + "_FR4_nt_" + chainKey)
					)
				}
				if !is_undefined(existingSeqKeys["FR4InFrame|nucleotide|" + chainKey]) {
					cdr3DerivedExprsProps = append(cdr3DerivedExprsProps,
						ntFr4.alias(numberingScheme + "_FR4InFrame_nt_" + chainKey)
					)
				}
			}
		}
		if len(cdr3DerivedExprsProps) > 0 {
			df_properties = df_properties.withColumns(cdr3DerivedExprsProps...)
		}
	}

	aggExpressions := []
	for h, _ in propertyHeaders {
		col := propertyHeaders[h]
		useNumbered := false
		if numberingDf != undefined && hasCdrAnnotationColumns && col.spec.name == "pl7.app/vdj/sequence/annotation" {
			if col.spec.domain["pl7.app/sequence/annotation/type"] == "CDRs" {
				chainKey := cdrAnnotationHeaderChain[h]
				if chainKey == undefined && !isSingleCell {
					chainKey = bulkNumberingChain
				}
				if chainKey != undefined && !is_undefined(cdrAnnotationAvailableByChain[chainKey]) {
					annHeader := "cdrs_annotations_" + chainKey
					aggExpressions = append(aggExpressions,
						pt.col(annHeader).maxBy(pt.col(mainAbundanceHeader)).alias(h)
					)
					useNumbered = true
				}
			}
		}
		if numberingEnabled && col.spec.name == "pl7.app/vdj/sequence" {
			feature := col.spec.domain["pl7.app/vdj/feature"]
			isNumberedFeature := false
			if useCdr3Numbering {
				isNumberedFeature = feature == "CDR3" || feature == "FR3" || feature == "FR4" || feature == "FR4InFrame"
			} else {
				isNumberedFeature = feature == "VDJRegion" || feature == "VDJRegionInFrame" || feature == "FR4InFrame" || slices.hasElement(numberingRegions, feature)
			}
			if !isNumberedFeature {
				feature = undefined
			}
			mappedFeature := feature
			chain := undefined
			if isSingleCell {
				receptor := col.spec.axesSpec[0].domain["pl7.app/vdj/receptor"]
				if receptor == "IG" {
					index := col.spec.domain["pl7.app/vdj/scClonotypeChain/index"]
					if index == "primary" {
						scChain := col.spec.domain["pl7.app/vdj/scClonotypeChain"]
						chain = scChain == "A" ? "IGHeavy" : scChain == "B" ? "IGLight" : undefined
					}
				}
			} else {
				chain = col.spec.axesSpec[0].domain["pl7.app/vdj/chain"]
				if chain == undefined { chain = col.spec.domain["pl7.app/vdj/chain"] }
			}
			alphabet := col.spec.domain["pl7.app/alphabet"]
			chainKey := chain == "IGHeavy" ? "H" : chain == "IGLight" ? "KL" : undefined
			if mappedFeature != undefined && chainKey != undefined && (alphabet == "aminoacid" || alphabet == "nucleotide") {
				headerNum := numberingScheme + "_" + mappedFeature + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				if useCdr3Numbering && feature == "CDR3" {
					trimHeader := "cdr3_trim_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
					aggExpressions = append(aggExpressions,
						pt.col(trimHeader).maxBy(pt.col(mainAbundanceHeader)).alias(h)
					)
				} else if useCdr3Numbering && (feature == "FR4" || feature == "FR4InFrame") {
					aggExpressions = append(aggExpressions,
						pt.concatStr([pt.col(h), pt.col(headerNum)], { delimiter: "" }).maxBy(pt.col(mainAbundanceHeader)).alias(h)
					)
				} else {
					aggExpressions = append(aggExpressions,
						pt.col(headerNum).maxBy(pt.col(mainAbundanceHeader)).alias(h)
					)
				}
				useNumbered = true
			}
		}
		if !useNumbered {
			aggExpressions = append(aggExpressions,
				pt.col(h).maxBy(pt.col(mainAbundanceHeader)).alias(h)
			)
		}
	}
	aggregatedDf := df_properties.groupBy("newClonotypeKey").agg(aggExpressions...)

	// label clonotype key deterministically on unique keys
	aggregatedDf = addClonotypeLabelColumnsPt(aggregatedDf, "newClonotypeKey", "clonotypeLabel")
	
	aggregatedDf.save("properties.tsv")
	
	// --- Run and process ---
	ptResult := ptWf.run()
	finalAbundancesTsvRaw := ptResult.getFile("abundances.tsv")
	finalPropertiesTsv := ptResult.getFile("properties.tsv")
	statsTsvContent := ptResult.getFileContent("stats.tsv")

	// Deanonymize abundances
	abundancesDeanonimization := render.createEphemeral(
		deanonimizationTpl,
		{
			mapping: mappingRef,
			clusteringResult: finalAbundancesTsvRaw
		}
	)
	finalAbundancesTsv := abundancesDeanonimization.output("deanonimizedTsv")


	// --- Construct specs ---
	datasetSpec := columns.getSpec(args.anchorRef)
	
	// Use customBlockLabel if user edited it, otherwise use defaultBlockLabel
	traceLabel := args.customBlockLabel
	if traceLabel == "" {
		traceLabel = args.defaultBlockLabel
	}
	if traceLabel == "" {
		traceLabel = text.join(definitionLabels, "-")
	}
	
	trace := pSpec.makeTrace(datasetSpec, {
		type: "milaboratories.redefine-clonotypes",
		importance: 30,
		label: traceLabel
	})

	newClonotypeKeySpec := maps.clone(clonotypeKeyAxisSpec)
	newClonotypeKeySpec.domain = maps.merge(newClonotypeKeySpec.domain, {
		"pl7.app/redefined-by": blockId,
		"pl7.app/vdj/clonotypeKey/structure": text.join(definitionLabels, "-") // override structure
	})

	abundanceAxes := [
		{
			column: "sampleId",	
			spec: sampleIdAxisSpec
		},
		{
			column: "newClonotypeKey",
			spec: newClonotypeKeySpec
		}
	]
	
	newAbundanceColumns := []
	for header, col in abundanceHeaders {
		newSpecUnnormalized := maps.clone(col.spec)
		delete(newSpecUnnormalized, "axesSpec")

		newAbundanceColumns = append(newAbundanceColumns, { 
			column: header, 
			id: header,
			spec: newSpecUnnormalized 
		})

		newSpecNormalized := maps.clone(newSpecUnnormalized)
		unit := newSpecNormalized.annotations["pl7.app/abundance/unit"]
		normalizedLabel := unit == "molecules" ? "UMI Fraction" : unit == "reads" ? "Read Fraction" : "Normalized Abundance"
		
		// Set normalized-specific spec name
		normalizedSpecName := unit == "molecules" ? "pl7.app/vdj/uniqueMoleculeFraction" : unit == "reads" ? "pl7.app/vdj/readFraction" : newSpecNormalized.name + "Normalized"
		newSpecNormalized.name = normalizedSpecName
		
		// Set normalized-specific annotations
		normalizedAnnotations := {
			"pl7.app/abundance/normalized": "true",
			"pl7.app/label": normalizedLabel,
			"pl7.app/min": "0",
			"pl7.app/max": "1",
			"pl7.app/format": ".2p"
		}
		
		// Preserve table visibility if it exists, otherwise set to optional
		if is_undefined(newSpecNormalized.annotations["pl7.app/table/visibility"]) {
			normalizedAnnotations["pl7.app/table/visibility"] = "optional"
		}
		
		newSpecNormalized.annotations = maps.merge(newSpecNormalized.annotations, normalizedAnnotations)
		if (newSpecNormalized.annotations["pl7.app/isAnchor"] == "true") {
			delete(newSpecNormalized.annotations, "pl7.app/isAnchor")
		}
		newSpecNormalized.valueType = "Double"
		
		normalizedHeader := "normalized_" + header
		newAbundanceColumns = append(newAbundanceColumns, { 
			column: normalizedHeader, 
			id: normalizedHeader,
			spec: newSpecNormalized 
		})
	}

	abundancePf := xsv.importFile(finalAbundancesTsv, "tsv", {
		axes: abundanceAxes,
		columns: newAbundanceColumns,
		storageFormat: "Parquet",
		partitionKeyLength: 1
	}, { splitDataAndSpec: true })

	propertyAxes := [
		{
			column: "newClonotypeKey",
			spec: newClonotypeKeySpec
		}
	]
	
	newPropertyColumns := [{
		column: "clonotypeLabel",
		spec: {
			name: "pl7.app/label",
			valueType: "String",
			annotations: {"pl7.app/label": "Clonotype Label"}
		}
	}]

	for header, col in propertyHeaders {
		newSpec :=	maps.clone(col.spec)
		delete(newSpec, "axesSpec")
		if numberingEnabled && col.spec.name == "pl7.app/vdj/sequence" {
			feature := col.spec.domain["pl7.app/vdj/feature"]
			if useCdr3Numbering {
				if feature == "CDR3" || feature == "FR4" || feature == "FR4InFrame" {
					newSpec.annotations = maps.merge(newSpec.annotations, {
						"pl7.app/vdj/numberingSchema": numberingScheme
					})
				}
			} else {
				if feature == "VDJRegion" || feature == "VDJRegionInFrame" || feature == "FR4InFrame" || slices.hasElement(numberingRegions, feature) {
					newSpec.annotations = maps.merge(newSpec.annotations, {
						"pl7.app/vdj/numberingSchema": numberingScheme
					})
				}
			}
		}

		newPropertyColumns = append(newPropertyColumns, { column: header, spec: newSpec })
	}

	propertyPf := xsv.importFile(finalPropertiesTsv, "tsv", {
		axes: propertyAxes,
		columns: newPropertyColumns,
		storageFormat: "Parquet",
		partitionKeyLength: 0
	}, { splitDataAndSpec: true })
	

	pfBuilder := pframes.pFrameBuilder()
	for k, v in abundancePf {
		pfBuilder.add(k, trace.inject(v.spec), v.data)
	}
	for k, v in propertyPf {
		pfBuilder.add(k, trace.inject(v.spec), v.data)
	}
	finalPf := pfBuilder.build()

	return {
		outputs: {
			statsTsvContent: statsTsvContent
		},
		exports: {
			pf: finalPf
		}
	}
})
