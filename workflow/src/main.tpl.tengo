// "Redefine clonotypes workflow"
wf := import("@platforma-sdk/workflow-tengo:workflow")
ll := import("@platforma-sdk/workflow-tengo:ll")
pt := import("@platforma-sdk/workflow-tengo:pt")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
text := import("text")
slices := import("@platforma-sdk/workflow-tengo:slices")
maps := import("@platforma-sdk/workflow-tengo:maps")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
canonical := import("@platforma-sdk/workflow-tengo:canonical")
json := import("json")
assets := import("@platforma-sdk/workflow-tengo:assets")
render := import("@platforma-sdk/workflow-tengo:render")

anonymizationTpl := assets.importTemplate(":anonymization")
deanonimizationTpl := assets.importTemplate(":deanonimization")
numberingTpl := assets.importTemplate(":anarci-numbering")

// --- Clonotype Label Generation (copied from MiXCR Clonotyping) ---
addClonotypeLabelColumnsPt := func(df, clonotypeKeyCol, clonotypeLabelCol) {
    prefixTempCol := clonotypeLabelCol + "_prefix_temp"
    rankTempCol := clonotypeLabelCol + "_rank_temp"

    df = df.withColumns(
        pt.col(clonotypeKeyCol).
            strReplace("\\d", "", { replaceAll: true }).
            strSlice(0, 5).
            strToUpper().
            alias(prefixTempCol)
    )

    df = df.withColumns(
        pt.rank(pt.col(clonotypeKeyCol)).
            over(pt.col(prefixTempCol)).
            alias(rankTempCol)
    )

    df = df.withColumns(
        pt.when(pt.col(rankTempCol).gt(pt.lit(1))).
            then(pt.concatStr([pt.lit("C"), pt.col(prefixTempCol), pt.col(rankTempCol).cast("String")], { delimiter: "-" })).
            otherwise(pt.concatStr([pt.lit("C"), pt.col(prefixTempCol)], { delimiter: "-" })).
            alias(clonotypeLabelCol)
    )

    return df.withoutColumns(prefixTempCol, rankTempCol)
}


wf.prepare(func(args) {
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.addAnchor("main", args.anchorRef)

	// Clonotype definition columns
	for i, colId in args.clonotypeDefinition {
		bundleBuilder.addSingle(colId, "clonotypeDefinition_" + i)
	}

	// All non-normalized abundance columns
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 0 }, { anchor: "main", idx: 1 }],
		annotations: {
			"pl7.app/isAbundance": "true",
			"pl7.app/abundance/normalized": "false"
		}
	}, "abundances")

	// All clonotype property columns
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }]
	}, "properties")

	// VDJRegion assembling feature sequences (AA/NT)
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }],
		name: "pl7.app/vdj/sequence",
		annotations: { "pl7.app/vdj/isAssemblingFeature": "true" }
	}, "vdjRegionSeqs")

	return {
		columns: bundleBuilder.build()
	}
})

wf.body(func(args) {
	columns := args.columns
	blockId := wf.blockId().getDataAsJson()

	abundanceCols := columns.getColumns("abundances")
	propertyCols := columns.getColumns("properties")
	
	clonotypeDefinitionCols := []
	for i, _ in args.clonotypeDefinition {
		clonotypeDefinitionCols = append(clonotypeDefinitionCols, columns.getColumn("clonotypeDefinition_" + i))
	}

	ll.assert(len(abundanceCols) > 0, "No abundance columns found in the dataset")

	mainAbundanceColIndex := -1
	for i, c in abundanceCols {
		if c.spec.annotations["pl7.app/abundance/isPrimary"] == "true" {
			mainAbundanceColIndex = i
			break
		}
	}
	ll.assert(mainAbundanceColIndex != -1, "No primary abundance column found")
	mainAbundanceCol := abundanceCols[mainAbundanceColIndex]

	sampleIdAxisSpec := mainAbundanceCol.spec.axesSpec[0]
	clonotypeKeyAxisSpec := mainAbundanceCol.spec.axesSpec[1]
	isSingleCell := clonotypeKeyAxisSpec.name == "pl7.app/vdj/scClonotypeKey"

	numberingRegions := ["FR1", "CDR1", "FR2", "CDR2", "FR3", "CDR3", "FR4"]
	numberingScheme := args.numberingScheme
	numberingEnabled := numberingScheme != undefined
	numberingHeaders := []
	numberingSpecs := {}
	numberingLabels := {}
	numberingTsv := undefined
	numberingChains := []
	numberingChainSet := {}

	// Anonymize sampleId axis (index 0)
	dataToAnonymize := {}
	for i, col in abundanceCols {
		dataToAnonymize["abundance_" + i] = col.data
	}

	anonymizationResult := render.create(anonymizationTpl, {
		data: dataToAnonymize,
		pKeyIndices: [0]
	})
	mappingRef := anonymizationResult.output("mapping")

	// --- Build the initial TSV for the pt workflow ---
	abundanceTsvBuilder := pframes.tsvFileBuilder()
	abundanceTsvBuilder.setAxisHeader(sampleIdAxisSpec, "sampleId")
	abundanceTsvBuilder.setAxisHeader(clonotypeKeyAxisSpec, "clonotypeKey")

	if numberingEnabled {
		vdjRegionCols := columns.getColumns("vdjRegionSeqs")
		allowedFeatures := { "VDJRegion": true, "VDJRegionInFrame": true }
		aaByChain := {}
		ntByChain := {}
		for _, col in vdjRegionCols {
			feature := col.spec.domain["pl7.app/vdj/feature"]
			if is_undefined(allowedFeatures[feature]) { continue }
			chain := undefined
			if isSingleCell {
				receptor := col.spec.axesSpec[0].domain["pl7.app/vdj/receptor"]
				if receptor != "IG" { continue }
				index := col.spec.domain["pl7.app/vdj/scClonotypeChain/index"]
				if index != "primary" { continue }
				scChain := col.spec.domain["pl7.app/vdj/scClonotypeChain"]
				chain = scChain == "A" ? "IGHeavy" : scChain == "B" ? "IGLight" : undefined
			} else {
				chain = col.spec.axesSpec[0].domain["pl7.app/vdj/chain"]
				if chain == undefined { chain = col.spec.domain["pl7.app/vdj/chain"] }
			}
			alphabet := col.spec.domain["pl7.app/alphabet"]
			chainKey := chain == "IGHeavy" ? "H" : chain == "IGLight" ? "KL" : undefined
			if chainKey == undefined { continue }
			if alphabet == "aminoacid" && is_undefined(aaByChain[chainKey]) {
				aaByChain[chainKey] = col
			} else if alphabet == "nucleotide" && is_undefined(ntByChain[chainKey]) {
				ntByChain[chainKey] = col
			}
		}

		hasH := !is_undefined(aaByChain["H"])
		hasKL := !is_undefined(aaByChain["KL"])
		if isSingleCell {
			ll.assert(hasH && hasKL, "VDJRegion amino acid sequences for both chains are required for numbering")
		} else {
			ll.assert(hasH || hasKL, "VDJRegion amino acid sequence is required for numbering")
		}

		numberingAaTsvBuilder := pframes.tsvFileBuilder()
		numberingAaTsvBuilder.setAxisHeader(clonotypeKeyAxisSpec, "clonotypeKey")
		numberingInputTsvBuilder := pframes.tsvFileBuilder()
		numberingInputTsvBuilder.setAxisHeader(clonotypeKeyAxisSpec, "clonotypeKey")

		for _, chainKey in ["H", "KL"] {
			col := aaByChain[chainKey]
			if col != undefined {
				headerAa := "vdjRegion_aa_" + chainKey
				numberingAaTsvBuilder.add(col, { header: headerAa })
				numberingInputTsvBuilder.add(col, { header: headerAa })
			}
		}
		for _, chainKey in ["H", "KL"] {
			col := ntByChain[chainKey]
			if col != undefined {
				headerNt := "vdjRegion_nt_" + chainKey
				numberingInputTsvBuilder.add(col, { header: headerNt })
			}
		}

		numberingAaTsvBuilder.mem("16GiB")
		numberingAaTsvBuilder.cpu(1)
		numberingInputTsvBuilder.mem("16GiB")
		numberingInputTsvBuilder.cpu(1)

		numberingAaTsv := numberingAaTsvBuilder.build()
		numberingInputTsv := numberingInputTsvBuilder.build()

		bulkChain := undefined
		if !isSingleCell {
			bulkChain = hasH ? "H" : "KL"
		}

		numbering := render.create(numberingTpl, {
			inputAaTsv: numberingAaTsv,
			inputTsv: numberingInputTsv,
			scheme: numberingScheme,
			isSingleCell: isSingleCell,
			bulkChain: bulkChain
		})
		numberingTsv = numbering.output("numbered", 24 * 60 * 60 * 1000)

		schemeLabel := numberingScheme == "imgt" ? "IMGT" : numberingScheme == "kabat" ? "Kabat" : "Chothia"
		for _, chainKey in ["H", "KL"] {
			if is_undefined(aaByChain[chainKey]) { continue }
			if is_undefined(numberingChainSet[chainKey]) {
				numberingChainSet[chainKey] = true
				numberingChains = append(numberingChains, chainKey)
			}
			chainDomain := chainKey == "H" ? "IGHeavy" : "IGLight"
			chainLabel := chainKey == "H" ? "Heavy" : "Light"
			for _, region in numberingRegions {
				for _, alphabet in ["aminoacid", "nucleotide"] {
					header := numberingScheme + "_" + region + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
					numberingHeaders = append(numberingHeaders, header)
					numberingLabels[header] = schemeLabel + " " + region + " " + (alphabet == "aminoacid" ? "aa" : "nt") + " " + chainLabel
					numberingSpecs[header] = {
						name: "pl7.app/vdj/sequence",
						valueType: "String",
						domain: {
							"pl7.app/vdj/feature": region,
							"pl7.app/vdj/chain": chainDomain,
							"pl7.app/alphabet": alphabet,
							"pl7.app/vdj/numberingScheme": numberingScheme
						},
						annotations: {
							"pl7.app/label": numberingLabels[header],
							"pl7.app/table/visibility": "optional"
						}
					}
				}
			}
			for _, feature in ["VDJRegion", "VDJRegionInFrame"] {
				for _, alphabet in ["aminoacid", "nucleotide"] {
					header := numberingScheme + "_" + feature + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
					numberingHeaders = append(numberingHeaders, header)
					numberingLabels[header] = schemeLabel + " " + feature + " " + (alphabet == "aminoacid" ? "aa" : "nt") + " " + chainLabel
					numberingSpecs[header] = {
						name: "pl7.app/vdj/sequence",
						valueType: "String",
						domain: {
							"pl7.app/vdj/feature": feature,
							"pl7.app/vdj/chain": chainDomain,
							"pl7.app/alphabet": alphabet,
							"pl7.app/vdj/numberingScheme": numberingScheme
						},
						annotations: {
							"pl7.app/label": numberingLabels[header],
							"pl7.app/table/visibility": "optional"
						}
					}
				}
			}
		}
	}

	mainAbundanceHeader := "abundance_" + mainAbundanceColIndex
	
	abundanceHeaders := {}
	for i, col in abundanceCols {
		header := "abundance_" + i
		anonymizedData := anonymizationResult.resolveOutput(["anonymizedData", "abundance_" + i])
		anonymizedCol := { spec: col.spec, data: anonymizedData }
		abundanceHeaders[header] = anonymizedCol
		abundanceTsvBuilder.add(anonymizedCol, { header: header })
	}
	
	definitionHeaders := []
	definitionLabels := []
	definitionHeaderSet := {}
	appendDefinition := func(header, label) {
		if label == undefined { label = header }
		if is_undefined(definitionHeaderSet[header]) {
			definitionHeaderSet[header] = true
			definitionHeaders = append(definitionHeaders, header)
			definitionLabels = append(definitionLabels, label)
		}
	}
	for i, col in clonotypeDefinitionCols {
		header := "clonotypeDefinition_" + i
		label := col.spec.annotations["pl7.app/label"]
		abundanceTsvBuilder.add(col, { header: header })

		useNumbered := false
		feature := col.spec.domain["pl7.app/vdj/feature"]
		if numberingEnabled && col.spec.name == "pl7.app/vdj/sequence" && col.spec.annotations["pl7.app/vdj/isAssemblingFeature"] == "true" && (feature == "VDJRegion" || feature == "VDJRegionInFrame") {
			chain := undefined
			if isSingleCell {
				receptor := col.spec.axesSpec[0].domain["pl7.app/vdj/receptor"]
				if receptor != "IG" { chain = undefined } else {
					index := col.spec.domain["pl7.app/vdj/scClonotypeChain/index"]
					if index != "primary" { chain = undefined } else {
						scChain := col.spec.domain["pl7.app/vdj/scClonotypeChain"]
						chain = scChain == "A" ? "IGHeavy" : scChain == "B" ? "IGLight" : undefined
					}
				}
			} else {
				chain = col.spec.axesSpec[0].domain["pl7.app/vdj/chain"]
				if chain == undefined { chain = col.spec.domain["pl7.app/vdj/chain"] }
			}
			alphabet := col.spec.domain["pl7.app/alphabet"]
			chainKey := chain == "IGHeavy" ? "H" : chain == "IGLight" ? "KL" : undefined
			if chainKey != undefined && (alphabet == "aminoacid" || alphabet == "nucleotide") {
				headerNum := numberingScheme + "_" + feature + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				appendDefinition(headerNum, numberingLabels[headerNum])
				useNumbered = true
			}
		}
		if !useNumbered {
			appendDefinition(header, label)
		}
	}

	abundancesTsv := abundanceTsvBuilder.build()

	propertyTsvBuilder := pframes.tsvFileBuilder()
	propertyTsvBuilder.setAxisHeader(clonotypeKeyAxisSpec, "clonotypeKey")
	propertyHeaders := {}
	for i, col in propertyCols {
		header := "property_" + i
		propertyHeaders[header] = col
		propertyTsvBuilder.add(col, { header: header })
	}
	propertiesTsv := propertyTsvBuilder.build()

	
	// --- Define the entire data pipeline in a single pt workflow ---
	ptWf := pt.workflow()

	df := ptWf.frame(abundancesTsv, {xsvType: "tsv"})
	numberingDf := undefined
	if numberingTsv != undefined {
		numberingDf = ptWf.frame(numberingTsv, {xsvType: "tsv"})
		df = df.join(numberingDf, {on: "clonotypeKey", how: "left"})
		numberingDerivedExprs := []
		for _, chainKey in numberingChains {
			for _, alphabet in ["aminoacid", "nucleotide"] {
				regionHeaders := []
				for _, region in numberingRegions {
					regionHeaders = append(regionHeaders, numberingScheme + "_" + region + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey)
				}
				vdjHeader := numberingScheme + "_VDJRegion_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				vdjInFrameHeader := numberingScheme + "_VDJRegionInFrame_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				concatExpr := pt.concatStr(slices.map(regionHeaders, func(h) { return pt.col(h) }), {delimiter: ""})
				numberingDerivedExprs = append(numberingDerivedExprs,
					concatExpr.alias(vdjHeader),
					concatExpr.alias(vdjInFrameHeader)
				)
			}
		}
		if len(numberingDerivedExprs) > 0 {
			df = df.withColumns(numberingDerivedExprs...)
		}
	}

	// 1. Calculate per-sample totals for each abundance column for normalization
	sampleTotalAggs := []
	totalColumnHeaders := []
	for header, _ in abundanceHeaders {
		totalHeader := header + "_total"
		sampleTotalAggs = append(sampleTotalAggs, pt.col(header).sum().alias(totalHeader))
		totalColumnHeaders = append(totalColumnHeaders, totalHeader)
	}
	sampleTotalsDf := df.groupBy("sampleId").agg(sampleTotalAggs...)

	// 2. Create the new clonotype definition string
	definitionColExprs := slices.map(definitionHeaders, func(h) { return pt.col(h) })
	dfWithNewKeyStr := df.withColumns(
		pt.
		  concatStr(definitionColExprs, {delimiter: "-"}).
		  hash("sha256", "base64_alphanumeric", 120).
		  alias("newClonotypeKey")
	)
	
	// 3. Calculate stats
	statsDf := dfWithNewKeyStr.select(
		pt.col("clonotypeKey").nUnique().alias("nClonotypesBefore"),
		pt.col("newClonotypeKey").nUnique().alias("nClonotypesAfter")
	)
	statsDf.saveContent("stats.tsv")

	// 4. Aggregate abundances
	abundanceAggs := []
	for h in maps.getKeys(abundanceHeaders) { 
		abundanceAggs = append(abundanceAggs, pt.col(h).sum().alias(h)) 
	}
	abundanceAggs = append(abundanceAggs, pt.col("clonotypeKey").maxBy(pt.col(mainAbundanceHeader)).alias("clonotypeKey"))
	df_abundances := dfWithNewKeyStr.groupBy("sampleId", "newClonotypeKey").agg(abundanceAggs...)

	// 8. Per-sample normalization
	df_abundances = df_abundances.join(sampleTotalsDf, {on: "sampleId", how: "left"})

	normExpressions := []
	for header, _ in abundanceHeaders {
		normExpressions = append(normExpressions, 
			pt.col(header).truediv(pt.col(header + "_total")).alias("normalized_" + header)
		)
	}
	df_abundances = df_abundances.withColumns(normExpressions...)
	df_abundances.save("abundances.tsv")

	// 5. Get representative properties
	
	df_properties := df_abundances.join(ptWf.frame(propertiesTsv, {xsvType: "tsv"}), {on: "clonotypeKey", how: "left"})
	if numberingDf != undefined {
		df_properties = df_properties.join(numberingDf, {on: "clonotypeKey", how: "left"})
		numberingDerivedExprsProps := []
		for _, chainKey in numberingChains {
			for _, alphabet in ["aminoacid", "nucleotide"] {
				regionHeaders := []
				for _, region in numberingRegions {
					regionHeaders = append(regionHeaders, numberingScheme + "_" + region + "_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey)
				}
				vdjHeader := numberingScheme + "_VDJRegion_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				vdjInFrameHeader := numberingScheme + "_VDJRegionInFrame_" + (alphabet == "aminoacid" ? "aa" : "nt") + "_" + chainKey
				concatExpr := pt.concatStr(slices.map(regionHeaders, func(h) { return pt.col(h) }), {delimiter: ""})
				numberingDerivedExprsProps = append(numberingDerivedExprsProps,
					concatExpr.alias(vdjHeader),
					concatExpr.alias(vdjInFrameHeader)
				)
			}
		}
		if len(numberingDerivedExprsProps) > 0 {
			df_properties = df_properties.withColumns(numberingDerivedExprsProps...)
		}
	}

	aggExpressions := []
	for h, _ in propertyHeaders {
		aggExpressions = append(aggExpressions,
			pt.col(h).maxBy(pt.col(mainAbundanceHeader)).alias(h)
		)
	}
	for _, h in numberingHeaders {
		aggExpressions = append(aggExpressions,
			pt.col(h).maxBy(pt.col(mainAbundanceHeader)).alias(h)
		)
	}
	aggregatedDf := df_properties.groupBy("newClonotypeKey").agg(aggExpressions...)

	// label clonotype key deterministically on unique keys
	aggregatedDf = addClonotypeLabelColumnsPt(aggregatedDf, "newClonotypeKey", "clonotypeLabel")
	
	aggregatedDf.save("properties.tsv")
	
	// --- Run and process ---
	ptResult := ptWf.run()
	finalAbundancesTsvRaw := ptResult.getFile("abundances.tsv")
	finalPropertiesTsv := ptResult.getFile("properties.tsv")
	statsTsvContent := ptResult.getFileContent("stats.tsv")

	// Deanonymize abundances
	abundancesDeanonimization := render.createEphemeral(
		deanonimizationTpl,
		{
			mapping: mappingRef,
			clusteringResult: finalAbundancesTsvRaw
		}
	)
	finalAbundancesTsv := abundancesDeanonimization.output("deanonimizedTsv")


	// --- Construct specs ---
	datasetSpec := columns.getSpec(args.anchorRef)
	
	// Use customBlockLabel if user edited it, otherwise use defaultBlockLabel
	traceLabel := args.customBlockLabel
	if traceLabel == "" {
		traceLabel = args.defaultBlockLabel
	}
	if traceLabel == "" {
		traceLabel = text.join(definitionLabels, "-")
	}
	
	trace := pSpec.makeTrace(datasetSpec, {
		type: "milaboratories.redefine-clonotypes",
		importance: 30,
		label: traceLabel
	})

	newClonotypeKeySpec := maps.clone(clonotypeKeyAxisSpec)
	newClonotypeKeySpec.domain = maps.merge(newClonotypeKeySpec.domain, {
		"pl7.app/redefined-by": blockId,
		"pl7.app/vdj/clonotypeKey/structure": text.join(definitionLabels, "-") // override structure
	})

	abundanceAxes := [
		{
			column: "sampleId",	
			spec: sampleIdAxisSpec
		},
		{
			column: "newClonotypeKey",
			spec: newClonotypeKeySpec
		}
	]
	
	newAbundanceColumns := []
	for header, col in abundanceHeaders {
		newSpecUnnormalized := maps.clone(col.spec)
		delete(newSpecUnnormalized, "axesSpec")

		newAbundanceColumns = append(newAbundanceColumns, { 
			column: header, 
			id: header,
			spec: newSpecUnnormalized 
		})

		newSpecNormalized := maps.clone(newSpecUnnormalized)
		unit := newSpecNormalized.annotations["pl7.app/abundance/unit"]
		normalizedLabel := unit == "molecules" ? "UMI Fraction" : unit == "reads" ? "Read Fraction" : "Normalized Abundance"
		
		// Set normalized-specific spec name
		normalizedSpecName := unit == "molecules" ? "pl7.app/vdj/uniqueMoleculeFraction" : unit == "reads" ? "pl7.app/vdj/readFraction" : newSpecNormalized.name + "Normalized"
		newSpecNormalized.name = normalizedSpecName
		
		// Set normalized-specific annotations
		normalizedAnnotations := {
			"pl7.app/abundance/normalized": "true",
			"pl7.app/label": normalizedLabel,
			"pl7.app/min": "0",
			"pl7.app/max": "1",
			"pl7.app/format": ".2p"
		}
		
		// Preserve table visibility if it exists, otherwise set to optional
		if is_undefined(newSpecNormalized.annotations["pl7.app/table/visibility"]) {
			normalizedAnnotations["pl7.app/table/visibility"] = "optional"
		}
		
		newSpecNormalized.annotations = maps.merge(newSpecNormalized.annotations, normalizedAnnotations)
		if (newSpecNormalized.annotations["pl7.app/isAnchor"] == "true") {
			delete(newSpecNormalized.annotations, "pl7.app/isAnchor")
		}
		newSpecNormalized.valueType = "Double"
		
		normalizedHeader := "normalized_" + header
		newAbundanceColumns = append(newAbundanceColumns, { 
			column: normalizedHeader, 
			id: normalizedHeader,
			spec: newSpecNormalized 
		})
	}

	abundancePf := xsv.importFile(finalAbundancesTsv, "tsv", {
		axes: abundanceAxes,
		columns: newAbundanceColumns,
		storageFormat: "Parquet",
		partitionKeyLength: 1
	}, { splitDataAndSpec: true })

	propertyAxes := [
		{
			column: "newClonotypeKey",
			spec: newClonotypeKeySpec
		}
	]
	
	newPropertyColumns := [{
		column: "clonotypeLabel",
		spec: {
			name: "pl7.app/label",
			valueType: "String",
			annotations: {"pl7.app/label": "Clonotype Label"}
		}
	}]

	for header, col in propertyHeaders {
		newSpec :=	maps.clone(col.spec)
		delete(newSpec, "axesSpec")

		newPropertyColumns = append(newPropertyColumns, { column: header, spec: newSpec })
	}
	for _, header in numberingHeaders {
		newPropertyColumns = append(newPropertyColumns, { column: header, spec: numberingSpecs[header] })
	}

	propertyPf := xsv.importFile(finalPropertiesTsv, "tsv", {
		axes: propertyAxes,
		columns: newPropertyColumns,
		storageFormat: "Parquet",
		partitionKeyLength: 0
	}, { splitDataAndSpec: true })
	

	pfBuilder := pframes.pFrameBuilder()
	for k, v in abundancePf {
		pfBuilder.add(k, trace.inject(v.spec), v.data)
	}
	for k, v in propertyPf {
		pfBuilder.add(k, trace.inject(v.spec), v.data)
	}
	finalPf := pfBuilder.build()

	return {
		outputs: {
			statsTsvContent: statsTsvContent
		},
		exports: {
			pf: finalPf
		}
	}
})
